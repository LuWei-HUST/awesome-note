管道-过滤器架构风格与仓库架构风格对比
    管道-过滤器架构
        数据处理方式 数据驱动机制，处理流程事先确定，交互性差
        系统可扩展性 容易添加新的过滤器，可扩展性好
        处理性能 涉及数据格式转换，有损性能；但支持过滤器并发调用，有利于性能提高
    仓库架构风格
        数据处理方式 数据统一保存在中央数据仓库，数据处理流程相对独立，支持交互式处理
        系统可扩展性 数据与处理解耦合，可动态添加和删除处理组件
        处理性能 不支持并行，有损性能；容错性和健壮性好

解释器风格、管道-过滤器风格和隐式调用风格对比
    管道-过滤器风格
        具有高内聚、低耦合、支持软件重用、扩展性好、支持并发等优点
        有编写复杂、不适合处理交互应用等缺点
    隐式调用风格
        隐式调用基于事件触发的思想，具备支持软件重用、改进系统方便等优点
        有构件放弃了对系统计算的控制、事件传递中的数据交换存在问题、语义依赖于被触发事件的上下文约束等缺点
    解释器风格
        核心是“解释”，一个规则可解释为A，另一个可解释为B，针对不同的语法规则，只需对解释器进行扩展即可，因此可应对语法规则的不断改变及扩展
        如果语法规则数量太多，会增加系统复杂性，性能下降

面向对象风格与解释器风格对比
    面向对象风格
        面向对象风格通过编写新的规则文件实现代码，并通过应用重启或热加载添加规则，可修改性较差
        面向对象风格通过策略模式定义规则对象，以程序逻辑实现规则，灵活性较差
        面向对象风格通常将规则以源代码描述，并以编译后的代码运行，性能好
        效率高、质量高、易维护、可修改性高、灵活性稍差、性能高
    解释器风格
        解释器风格通过编写新的规则文件，并通过导入资源文件或外部配置添加规则，可修改性好
        解释器风格可灵活定义规则计算表达式，灵活性更好
        解释器风格需要加载规则、解析规则、规则运算，再得出结果，性能较差
        可修改性高、个性化和灵活性强、性能较差


数据库设计的6个阶段
    用户需求分析 功能、性能、限制
        对数据库应用系统所要涉及的内容（数据）和功能（行为）的整理和描述
        综合各个用户的应用需求，对现实世界要处理的对象（组织、部门和企业等）进行详细调查，在了解现行系统的概况，确定新系统功能的过程中，收集支持系统目标的基础数据和处理方法
    概念结构设计 形成独立于计算机系统的企业信息模型；描述概念模型的理想工具：E-R图
        选择局部应用
        逐一设计分E-R图
        E-R图合并
    逻辑结构设计 将抽象的概念模型转化为与选用的DBMS产品所支持的数据模型相符合的逻辑模型，它是物理结构设计的基础。包括模式初始设计、子模式设计、应用程序设计、模式评价以及模式求精
        E-R图转化为关系模式
        关系模式规范化
        确定完整性约束
        确定用户视图 数据安全性、独立性
        反规范化 冗余列、派生列、表重组和表分割
            冗余列
                在多个表中增加相同的常用列，可用来在查询时避免连接操作
            派生列
                把可通过表中其他数据计算生成的列作为固定的列插入到表中，可在查询时减少计算量
            表重组
                如果许多用户需要查看两个表连接出来的结果数据，则把这两个表重新组成一个表来减少连接从而提高性能
            表分割
                水平分割把表按记录进行分割，把数据放到多个独立的表中，主要用于表数据规模很大、表中数据相对独立或数据需要存放到多个介质上时使用
                垂直分割对表按列进行分割，通常将主键与部分列放到一个表中，主键与其他列放到另一个表中，在查询时较少I/O次数
            带来数据不一致性，可采用应用程序同步、批量处理同步和触发器同步方法解决
                应用程序同步
                    在同一事务中对所有涉及的表进行增删改操作，同一逻辑必须在所有的应用中使用和维护，缺点是容易遗漏，特别是需求变化时，不易于维护
                批量处理同步
                    通过定期运行批处理作业或存储过程对数据库进行修改，适用于对实时性要求不高的情况
                触发器同步
                    对数据的任何修改立即触发对数据库某些列的相应修改，实时性好，也易于维护
    物理结构设计 逻辑模型的具体实现方案
        确定数据分布
            数据是集中管理还是分布式管理，如何分布
        确定数据的存储结构
            物理结构、索引
        确定数据的访问方式
            存储记录结构设计 常用数据分布在不同的磁盘组上
            存储记录布局 聚簇功能
            存取方法的设计 建立索引
    数据库实施阶段 建立数据库，编制和调试应用程序，组织数据入库，试运行
    数据库运行和维护阶段 投入使用，不断评价、调整与修改

NoSQL体系框架
    由下至上
        数据持久层
            数据存储形式 基于内存、硬盘、内存和硬盘接口、订制可插拔
        数据分布层
            数据分布
                CAP支持，可用于水平扩展
                多数据中心支持，可以保证在横跨多数据中心时也能够平稳运行
                动态部署支持，可以再运行着的集群中动态地添加和删除节点
        数据逻辑模型层
        接口层
        
对现实事物抽象认识的3中方法
    分类 对现实世界的事物，按照其具有的共同特征和行为，定义一种类型
    聚集 定义某一类型的属性
    概括 由一种已知类型定义新的类型。通常，将已知类型称为超类，新定义的类型称为子类。子类是超类的一个子集。例如研究生是学生的一个子集

Redis数据类型
    string 二进制安全的字符串，可以包含任何数据（图片或序列化对象）
    list 按添加顺序保持顺序的字符串列表
    set 无序的字符串集合
    sorted set 已排序的字符串集合
    ZSet 有序集合，每个元素有一个分数
    hash key-value对的一种集合，更节省空间，描述用户信息较为方便
    bitmap 更细化的一种操作，以bit为单位
    hyperloglog 基于概率的数据结构
    geo 存储地理位置信息
    stream 流，相当于消息队列的topic

Redis持久化
    RDB（Redis Data Base）持久化方式
    AOF（Append Only File）持久化方式
        磁盘更新频率 RDB更新频率比AOF低
        数据安全 AOF可以保证数据不丢失，比RDB安全
        数据一致性 RDB间隔一段时间存储，可能发生数据丢失和不一致；AOF通过append模式写文件，即使服务器宕机，也可通过redis-check-aof工具解决数据一致性问题
        重启性能 RDB比AOF更高
        数据文件大小 RDB更小

Redis内存淘汰机制
    volatile-lru 针对设置了过期时间的key，使用lru（Least Recently Used，最近很少使用）算法进行淘汰
    allkeys-lru 针对所有key使用lru算法进行淘汰
    volatile-lfu 针对设置了过期时间的key，使用lfu（Least Frequently Used，最近很少使用）算法进行淘汰
    allkeys-lfu 针对所有key使用lfu算法进行淘汰
    volatile-random 针对设置了过期时间的key，随机淘汰
    allkeys-random 对所有key，随机淘汰
    volatile-ttl 针对设置了过期时间的key，越早过期的越早被淘汰
    noeviction 不淘汰任何数据，内存超过限制时写入报错

Redis和MySQL数据实时同步方案
    引用MySQL的事务，事务有一致性保证，事务提交成功后再更新缓存
    在缓存中引用访问控制位，数据库数据变化后，同步变更对应的访问控制位，然后从缓存查询时，首先检查访问控制位，有变化就从数据库查，无变化直接从缓存返回数据
    通过数据库中间件产品保证缓存和数据库数据的实时同步

缓存和数据库的数据更新方案
    数据实时同步更新方案
        把每个“订单反馈”作为一个事务，只有缓存和数据库中的数据同时完成更新（同步）后事务才算提交成功
    数据异步准实时更新方案
        更新数据时，在同一事务内通过消息队列发布待更新数据的消息，缓存通过订阅消息队列异步更新，但数据库采用同步更新

TCP和UDP协议对比
    TCP在IP协议提供的不可靠数据服务的基础上，采用了重发技术，为应用程序提供了一个可靠的、面向连接的、全双工的数据传输服务
        一般用于传输数据量比较少，且对可靠性要求高的场景
    UDP是一种不可靠的、无连接的协议，可以保证应用程序进程间的通信
        与TCP相比，UDP是一种无连接的协议，错误检测功能较弱

数据流图和数据字典在需求分析和设计阶段的作用
    在需求分析阶段，数据流图通过数据的输入、流向处理过程、输出，可以清晰地反映出系统必须完成的逻辑功能，从而尽早发现是否有需要输入或输出的信息被遗漏，以及系统各部分的逻辑是否存在错误
    数据字典是描述数据的信息集合，通过数据字典可使参与人员对模型中的元素有共同的理解
    在设计阶段，根据数据流图，通过变换分析和事务分析的方法，可设计出系统的模块结构（系统结构图）
    根据数据字典中的数据存储描述可建立数据库存储设计

心跳检测技术和超时探测技术
    心跳检测技术是指节点以固定频率向其他节点发送心跳信息，表示自己是存活的，如果在规定的时间内其他节点没有收到来自某节点的心跳，就认定该节点失效，其资源和服务就会被接管
        优点是可以快速反应，缺点是容易误判
    超时探测技术是节点主动向被探测节点发出ping信号，被探测节点在收到ping信号后回复一个echo信号，表示自己状态良好，还可以附加一些状态信息。如果在预定的时间之后未收到echo信号，
        则判定被探测节点失效，其特点是可以获得更详细的探测结果，但需主动进行探测

数据分片中的哈希算法和一致性哈希算法
    哈希算法
        把任意长的输入通过某种哈希算法变换成固定长度的一个哈希值。不同的输入，可能会哈希出相同的结果，所以不能由哈希值来确定唯一的输入值
    一致性哈希算法
        将整个哈希值空间映射成一个按顺时针方向组织的虚拟圆环，使用哈希算法算出数据哈希值，然后根据哈希值的位置沿圆环顺时针查找，将数据分配到第一个遇到的集群节点进行缓存。
        一致性哈希算法能尽可能地改变已存在的服务请求与处理请求服务器之间的映射关系，解决了简单哈希算法在分布式哈希表中存在的动态伸缩问题。
        可扩展性高，更好地适应数据的快速增长

布隆过滤器
    创建一个全为0的超长数组，将数据用多个哈希算法计算出位置并标记为1，查询时，对查询元素用同样的函数计算位置，有任何一个为0，则肯定不在，全为1，则有可能在
    优点
        占用内存小
        增加和查询元素的时间复杂度为O(K)，K为哈希函数的个数
        哈希函数之间没有关系，可以并行计算
        不需要存储元素本身，在某些有保密要求的场景下有优势
    缺点
        有误判率
        不能获取元素本身
        无法删除元素

MQTT协议
    Message Queuing Telemetry Transport，即消息队列遥测传输协议
    它是一个专门针对物联网开发的轻量级传输协议，旨在为位于不稳定的网络环境中的低算能、低带宽的边缘物联网设备提供可靠的网络服务
    MQTT协议针对低带宽、低计算能力的网络设备做了特殊的优化，使得其能适应物联网数据传输场景

OPC协议
    OPC是基于Windows COM/DCOM的工业通信协议，用于实现不同设备与软件间的数据交换。
    OPC UA是OPC的升级版，它独立于平台，内置安全机制，并支持复杂信息建模，实现了从底层设备到云端的安全、跨平台数据集成。

传统云计算模型引入边缘计算的优势
    数据通信方面
        很多计算在边缘数据中心或边缘设备本身进行处理，数据无需传输回中央服务器，可极大减少网络负载
    数据安全方面
        边缘计算将在不同的数据中心和设备之间分配数据处理工作，黑客无法通过攻击一台设备来影响整个网络
    系统性能方面
        由于很多功能直接由边缘设备完成而不需依赖于中央服务器，因此系统性能更高