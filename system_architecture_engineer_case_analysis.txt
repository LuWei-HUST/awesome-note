
数据流体系结构风格
    批处理风格
        每个处理步骤是一个单独的程序，每一步必须在前一步结束后才能开始，并且数据必须是完整的，以整体的方式传递
        优点：
            可以在系统资源空闲的时候进行
            比操作单条记录效率更高
            不必在小任务之间频繁切换
            线性逻辑，便于开发测试
            数据一致性好
        缺点：
            高延时
            对硬件和资源要求高
            结果时效性不足
            缺乏交互性
    管道-过滤器风格
        每个处理步骤由一个过滤器实现，处理步骤之间的数据传输由管道负责
        优点：
            高内聚、低耦合，每个过滤器功能单一、职责明确，过滤器之间不直接通信，通过管道交换数据
            过滤器功能明确，便于重用
            易于维护，哪个需要修改就改哪个，不影响其他
            易于扩展，方便创建新的过滤器
            将复杂任务分解为一系列简单任务
            支持并发
        缺点：
            数据在管道中传递，通常需要格式转换，带来性能开销
            交互性差，不适用交互式应用

调用/返回体系结构风格
    主程序/子程序风格
        过程调用作为交互机制，即充当连接件
        优点：
            简单直观，结构清晰
            易于设计与实现
            定义良好的子程序，具备高可重用性
        缺点：
            主程序与子程序之间、子程序与子程序之间紧耦合
            单一控制流，带来难以并发或者阻塞问题
            可扩展性差，需修改主控制流程
    
    面向对象体系结构风格
        建立在数据抽象和面向对象的基础上，数据的表示方法和它们的相应操作封装在一个抽象数据类型或对象中
        优点：
            封装，数据和操作数据的方法捆绑在一起，并隐藏内部实现细节，带来高内聚、低耦合的特性
            继承，子类扩展父类，实现代码的重用；多态，不同类的对象对同一消息可作出不同的响应；可扩展性高
            易于建模和理解，降低设计复杂度
            高可重用性，通过雷和对象的概念，功能可以被方便地打包和重用
            易于测试，对象是封装，便于对单个类进行单元测试
        缺点：
            对象的创建和销毁、动态绑定（多态）、深层次的继承链中的方法查找带来一定的性能开销
            过度设计
            滥用继承
    
    层次型体系结构风格
        每一层最多只影响两层，允许每层用不同的方法实现
        优点：
            关注点分离，每一层都有明确的定义、单一的职责；高内聚
            松耦合，只要层间接口不变，某一层的内部实现可以自由修改；也便于维护
            可重用，特定的层可以被不同的上层应用复用
            易于标准化和开发，每一层精确定义，开发工作可以并行
            可以对每一层单独测试
        缺点：
            请求需要通过所有层，带来性能损耗
            阻碍跨层优化，有些情况跨层性能更优，但是会破坏架构
        
    客户端/服务器体系结构风格
        两层C/S体系结构：数据库服务器、客户应用程序和网络；三层C/S体系结构：数据库服务器、应用服务器、客户应用程序和网络
        优点：
            职责分离，结构清晰
            数据、业务逻辑和关键资源集中于服务器端，便于维护和安全控制
            可升级服务器或负载均衡以支持更多客户端
            客户端多样性
        缺点：
            服务器单点故障
            严重依赖网络，网络延迟或中断影响巨大
            服务器可能被集中攻击

        三层相比两层：
            服务器压力更均衡
            业务逻辑集中于应用服务器，不需要分发安装到每一个客户端
            对应用服务器扩展即可扩展业务处理能力
            业务逻辑受保护，客户端不直接访问数据库

以数据为中心的体系结构风格
    仓库体系结构风格
        中央数据结构说明当前数据状态，一组独立构件对中央数据进行操作
        优点：
            高度可扩展，可维护，易于添加新的处理组件
            数据与处理解耦合，处理组件只依赖于中央数据仓库
            集中化的数据管理，一致性好
            支持交互处理
        缺点：
            中央数据仓库可能成为性能瓶颈，以及单点故障问题
            不支持并行

    黑板体系结构风格
        适用于解决复杂的非结构化问题，求解过程中可综合多种不同的数据源；应用于信号处理领域（语音、模式识别）和松耦合代理数据共享存取
        优点：
            集成多种异构知识
            支持对不确定性和不完整性问题的求解
            便于扩展，易于添加新的知识源
            数据于知识源解耦，知识源可重用
        缺点：
            控制逻辑复杂，难以调试测试
            性能开销较大
            难以保证正确性和确定性

虚拟机体系结构风格
    解释器体系结构风格
        一个解释器通常包括完成解释工作的解释引擎，一个包含将被解释的代码的存储区，一个记录解释引擎当前工作状态的数据结构，
        以及一个记录源代码被解释执行进度的数据结构
        优点：
            极高的灵活性和动态性，可在运行时读取、解释并执行代码
            强大的可移植性，只要解释器移植，所有用该语言编写的程序都能在其上运行
            高度可扩展，相对容易在语言中添加功能或特性
        缺点：
            性能开销大，解释运行，动态类型
            错误检测延迟，需运行时才发现错误
    
    规则系统体系结构风格
        包括规则集、规则解释器、规则/数据选择器及工作内存
        优点：
            业务逻辑被表示为独立的、声明式的规则，比较直观
            逻辑与控制分离
            可维护性和可扩展性高，添加新功能只需添加新规则
        缺点：
            性能较低，规则与事实数量较大时，匹配计算开销很大
            行为难以预测、调试
            规则执行顺序不确定

独立构件体系结构风格
    进程通信体系结构风格
        消息传递的方式可以是点到点、异步或同步方式以及远程过程调用等
        优点：
            强隔离性与高容错性，进程拥有独立的地址空间，不影响其他进程
            进程任务确定、明确
            可扩展性高，可分布式部署，进程独立，可部署在不同的物理机上
            可使用不同的技术，只要通过相同的协议通信（HTTP/REST或gRPC）
            多核优势
        缺点：
            性能开销大，进程创建、切换，以及进程间通信
            可能导致数据一致性问题
            死锁风险
            序列化、反序列化需求

    事件系统体系结构风格
        基于事件的隐式调用，当一个事件被触发，系统自动调用在这个事件中注册的所有过程
        优点：
            组件可复用性高
            可扩展性高，增加监听事件的过程即可
            事件广播，一因多果
            适用于不确定性环境
        缺点：
            组件放弃了控制权，难以预测后果
            调试和追踪执行过程困难
            不确定性高
            事件管理和上下文切换带来性能开销


管道-过滤器架构风格与仓库架构风格对比
    管道-过滤器架构
        数据处理方式 数据驱动机制，处理流程事先确定，交互性差
        系统可扩展性 容易添加新的过滤器，可扩展性好
        处理性能 涉及数据格式转换，有损性能；但支持过滤器并发调用，有利于性能提高
    仓库架构风格
        数据处理方式 数据统一保存在中央数据仓库，数据处理流程相对独立，支持交互式处理
        系统可扩展性 数据与处理解耦合，可动态添加和删除处理组件
        处理性能 不支持并行，有损性能；容错性和健壮性好

解释器风格、管道-过滤器风格和隐式调用风格对比
    管道-过滤器风格
        具有高内聚、低耦合、支持软件重用、扩展性好、支持并发等优点
        有编写复杂、不适合处理交互应用等缺点
    隐式调用风格
        隐式调用基于事件触发的思想，具备支持软件重用、改进系统方便等优点
        有构件放弃了对系统计算的控制、事件传递中的数据交换存在问题、语义依赖于被触发事件的上下文约束等缺点
    解释器风格
        核心是“解释”，一个规则可解释为A，另一个可解释为B，针对不同的语法规则，只需对解释器进行扩展即可，因此可应对语法规则的不断改变及扩展
        如果语法规则数量太多，会增加系统复杂性，性能下降

面向对象风格与解释器风格对比
    面向对象风格
        面向对象风格通过编写新的规则文件实现代码，并通过应用重启或热加载添加规则，可修改性较差
        面向对象风格通过策略模式定义规则对象，以程序逻辑实现规则，灵活性较差
        面向对象风格通常将规则以源代码描述，并以编译后的代码运行，性能好
        效率高、质量高、易维护、可修改性高、灵活性稍差、性能高
    解释器风格
        解释器风格通过编写新的规则文件，并通过导入资源文件或外部配置添加规则，可修改性好
        解释器风格可灵活定义规则计算表达式，灵活性更好
        解释器风格需要加载规则、解析规则、规则运算，再得出结果，性能较差
        可修改性高、个性化和灵活性强、性能较差


数据库设计的6个阶段
    用户需求分析 功能、性能、限制
        对数据库应用系统所要涉及的内容（数据）和功能（行为）的整理和描述
        综合各个用户的应用需求，对现实世界要处理的对象（组织、部门和企业等）进行详细调查，在了解现行系统的概况，确定新系统功能的过程中，收集支持系统目标的基础数据和处理方法
    概念结构设计 形成独立于计算机系统的企业信息模型；描述概念模型的理想工具：E-R图
        选择局部应用
        逐一设计分E-R图
        E-R图合并
    逻辑结构设计 将抽象的概念模型转化为与选用的DBMS产品所支持的数据模型相符合的逻辑模型，它是物理结构设计的基础。包括模式初始设计、子模式设计、应用程序设计、模式评价以及模式求精
        E-R图转化为关系模式
        关系模式规范化
        确定完整性约束
        确定用户视图 数据安全性、独立性
        反规范化 冗余列、派生列、表重组和表分割
            冗余列
                在多个表中增加相同的常用列，可用来在查询时避免连接操作
            派生列
                把可通过表中其他数据计算生成的列作为固定的列插入到表中，可在查询时减少计算量
            表重组
                如果许多用户需要查看两个表连接出来的结果数据，则把这两个表重新组成一个表来减少连接从而提高性能
            表分割
                水平分割把表按记录进行分割，把数据放到多个独立的表中，主要用于表数据规模很大、表中数据相对独立或数据需要存放到多个介质上时使用
                垂直分割对表按列进行分割，通常将主键与部分列放到一个表中，主键与其他列放到另一个表中，在查询时较少I/O次数
            带来数据不一致性，可采用应用程序同步、批量处理同步和触发器同步方法解决
                应用程序同步
                    在同一事务中对所有涉及的表进行增删改操作，同一逻辑必须在所有的应用中使用和维护，缺点是容易遗漏，特别是需求变化时，不易于维护
                批量处理同步
                    通过定期运行批处理作业或存储过程对数据库进行修改，适用于对实时性要求不高的情况
                触发器同步
                    对数据的任何修改立即触发对数据库某些列的相应修改，实时性好，也易于维护
    物理结构设计 逻辑模型的具体实现方案
        确定数据分布
            数据是集中管理还是分布式管理，如何分布
        确定数据的存储结构
            物理结构、索引
        确定数据的访问方式
            存储记录结构设计 常用数据分布在不同的磁盘组上
            存储记录布局 聚簇功能
            存取方法的设计 建立索引
    数据库实施阶段 建立数据库，编制和调试应用程序，组织数据入库，试运行
    数据库运行和维护阶段 投入使用，不断评价、调整与修改

NoSQL体系框架
    由下至上
        数据持久层
            数据存储形式 基于内存、硬盘、内存和硬盘接口、订制可插拔
        数据分布层
            数据分布
                CAP支持，可用于水平扩展
                多数据中心支持，可以保证在横跨多数据中心时也能够平稳运行
                动态部署支持，可以再运行着的集群中动态地添加和删除节点
        数据逻辑模型层
        接口层
        
对现实事物抽象认识的3中方法
    分类 对现实世界的事物，按照其具有的共同特征和行为，定义一种类型
    聚集 定义某一类型的属性
    概括 由一种已知类型定义新的类型。通常，将已知类型称为超类，新定义的类型称为子类。子类是超类的一个子集。例如研究生是学生的一个子集

Redis数据类型
    string 二进制安全的字符串，可以包含任何数据（图片或序列化对象）
    list 按添加顺序保持顺序的字符串列表
    set 无序的字符串集合
    sorted set 已排序的字符串集合
    ZSet 有序集合，每个元素有一个分数
        命令：
        ZADD 向zset中添加元素或分数
        ZRANGE 返回指定区间里的元素
        ZREVRANGE 返回指定区间里的元素，按照分数降序遍历
        ZCARD 获取指定zset的元素个数
        ZCOUNT 返回分数在min和max之间的元素个数
        ZRANK 返回成员在集合中的正序排名
        ZREVRANK 返回成员在集合中的逆序排名
        ZSCORE 查询指定元素的分数
    hash key-value对的一种集合，更节省空间，描述用户信息较为方便
    bitmap 更细化的一种操作，以bit为单位
    hyperloglog 基于概率的数据结构
    geo 存储地理位置信息
    stream 流，相当于消息队列的topic

Redis持久化
    RDB（Redis Data Base）持久化方式
    AOF（Append Only File）持久化方式
        磁盘更新频率 RDB更新频率比AOF低
        数据安全 AOF可以保证数据不丢失，比RDB安全
        数据一致性 RDB间隔一段时间存储，可能发生数据丢失和不一致；AOF通过append模式写文件，即使服务器宕机，也可通过redis-check-aof工具解决数据一致性问题
        重启性能 RDB比AOF更高
        数据文件大小 RDB更小

Redis内存淘汰机制
    volatile-lru 针对设置了过期时间的key，使用lru（Least Recently Used，最近很少使用）算法进行淘汰
    allkeys-lru 针对所有key使用lru算法进行淘汰
    volatile-lfu 针对设置了过期时间的key，使用lfu（Least Frequently Used，最不经常使用）算法进行淘汰
    allkeys-lfu 针对所有key使用lfu算法进行淘汰
    volatile-random 针对设置了过期时间的key，随机淘汰
    allkeys-random 对所有key，随机淘汰
    volatile-ttl 针对设置了过期时间的key，越早过期的越早被淘汰
    noeviction 不淘汰任何数据，内存超过限制时写入报错

Redis和MySQL数据实时同步方案
    引用MySQL的事务，事务有一致性保证，事务提交成功后再更新缓存
    在缓存中引用访问控制位，数据库数据变化后，同步变更对应的访问控制位，然后从缓存查询时，首先检查访问控制位，有变化就从数据库查，无变化直接从缓存返回数据
    通过数据库中间件产品保证缓存和数据库数据的实时同步

Redis集群的三种模式
    主从模式
        优点：读写分离、同步非阻塞服务、负载均衡
        缺点：容错性差、数据一致性差、在线扩容困难
    哨兵模式
        优点：自动故障转移、监控与通知、简化运维处理
        缺点：部署复杂、网络通信频繁、在线扩容困难
    集群模式：
        优点：无中心架构、可用性好、伸缩性较好、降低运维成本
        缺点：配置复杂、数据一致性差、客户端实现复杂、资源隔离性差

ElastiCache与自建Redis集群的差异
    成本 ElastiCache提供按需付费的云服务，初期成本较低，但业务增长后长期成本可能较高；自建Redis集群需要自行承担硬件和维护成本，但长期成本可控
    灵活性 ElastiCache提供多种配置选项，但可能受限于云服务提供商的设定；自建Redis集群可以根据业务需求自由配置和优化
    扩展性 ElastiCache支持自动扩展，但可能受限于云服务提供商的扩展策略；自建Redis集群可以通过增加节点和重新分片来灵活扩展

基于数据库的分布式锁和基于redis的分布式锁的对比
    基于数据库
        优点：实现简单、无需额外依赖、适用范围广且具有持久性
        缺点：单点问题——数据库是单点，挂掉会导致业务系统不可用；没有失效时间——操作失败会导致记录一直存在，其他线程无法获取锁；非阻塞——插入操作失败直接报错，没有获得锁的线程
            需要再次触发获取操作；非重入——同一线程在释放所之前无法再次获得该锁
    基于redis
        优点：容错性好、性能好
        缺点：可能存在死锁问题，锁的获得者若崩溃会导致无法释放锁

基于redis的数据库锁死锁场景
    A、B两个进程，尝试获取两个共享资源R1和R2，A成功获取R1，B成功获取R2，而A继续尝试获取B持有的R2，B继续尝试获取A持有的R1；互相等待对方释放锁，导致死锁

MongoDB对于存储非关系型数据的优势
    1、MongoDB采用分布式文件系统和空间索引，提高了矢量空间数据的存储和处理效率
    2、MongoDB支持多种空间分析和查询操作，可对数据进行深度分析和挖掘
    3、MongoDB扩展性好，可以根据业务需要增加字段，可以表达丰富的地理信息

HDFS使用热数据、温数据和冷数据存储
    HDFS 允许将不活跃的数据分配到比较便宜的存储上，用于归档或冷存储。
    HDFS 可以通过设置存储策略，将较旧的数据从昂贵的高性能存储上转移到较便宜的存储设备上。
    对冷数据,选择使用容量大、读写性能不高的存储介质，如机械硬盘;
    对于热数据，可使用 SSD 硬盘存储。这两种存储在读写效率上差距大。异构特性允许我们对不同文件选择不同的存储介质进行保存，以实现性能的最大化。
    “热”数据:一般新产生的数据被应用程序大量使用，应该采用 SSD存储;
    “温”数据:随着时间的推移，数据访问频率逐渐降低，则可以采用SAS 盘存储；
    “冷”数据:当数据使用率下降得更多，应采用容量大而便宜的 SATA 盘存储。

分布式数据库缓存的主要作用
    减少数据库压力，提高数据访问速度，从而提升系统整体性能

缓存和数据库的数据更新方案
    数据实时同步更新方案
        把每个“订单反馈”作为一个事务，只有缓存和数据库中的数据同时完成更新（同步）后事务才算提交成功
    数据异步准实时更新方案
        更新数据时，在同一事务内通过消息队列发布待更新数据的消息，缓存通过订阅消息队列异步更新，但数据库采用同步更新

TCP和UDP协议对比
    TCP在IP协议提供的不可靠数据服务的基础上，采用了重发技术，为应用程序提供了一个可靠的、面向连接的、全双工的数据传输服务
        一般用于传输数据量比较少，且对可靠性要求高的场景
    UDP是一种不可靠的、无连接的协议，可以保证应用程序进程间的通信
        与TCP相比，UDP是一种无连接的协议，错误检测功能较弱

数据流图和数据字典在需求分析和设计阶段的作用
    在需求分析阶段，数据流图通过数据的输入、流向处理过程、输出，可以清晰地反映出系统必须完成的逻辑功能，从而尽早发现是否有需要输入或输出的信息被遗漏，以及系统各部分的逻辑是否存在错误
    数据字典是描述数据的信息集合，通过数据字典可使参与人员对模型中的元素有共同的理解
    在设计阶段，根据数据流图，通过变换分析和事务分析的方法，可设计出系统的模块结构（系统结构图）
    根据数据字典中的数据存储描述可建立数据库存储设计

心跳检测技术和超时探测技术
    心跳检测技术是指节点以固定频率向其他节点发送心跳信息，表示自己是存活的，如果在规定的时间内其他节点没有收到来自某节点的心跳，就认定该节点失效，其资源和服务就会被接管
        优点是可以快速反应，缺点是容易误判
    超时探测技术是节点主动向被探测节点发出ping信号，被探测节点在收到ping信号后回复一个echo信号，表示自己状态良好，还可以附加一些状态信息。如果在预定的时间之后未收到echo信号，
        则判定被探测节点失效，其特点是可以获得更详细的探测结果，但需主动进行探测

数据分片中的哈希算法和一致性哈希算法
    哈希算法
        把任意长的输入通过某种哈希算法变换成固定长度的一个哈希值。不同的输入，可能会哈希出相同的结果，所以不能由哈希值来确定唯一的输入值
    一致性哈希算法
        将整个哈希值空间映射成一个按顺时针方向组织的虚拟圆环，使用哈希算法算出数据哈希值，然后根据哈希值的位置沿圆环顺时针查找，将数据分配到第一个遇到的集群节点进行缓存。
        一致性哈希算法能尽可能地改变已存在的服务请求与处理请求服务器之间的映射关系，解决了简单哈希算法在分布式哈希表中存在的动态伸缩问题。
        可扩展性高，更好地适应数据的快速增长

布隆过滤器
    创建一个全为0的超长数组，将数据用多个哈希算法计算出位置并标记为1，查询时，对查询元素用同样的函数计算位置，有任何一个为0，则肯定不在，全为1，则有可能在
    优点
        占用内存小
        增加和查询元素的时间复杂度为O(K)，K为哈希函数的个数
        哈希函数之间没有关系，可以并行计算
        不需要存储元素本身，在某些有保密要求的场景下有优势
    缺点
        有误判率
        不能获取元素本身
        无法删除元素

MQTT协议
    Message Queuing Telemetry Transport，即消息队列遥测传输协议
    它是一个专门针对物联网开发的轻量级传输协议，旨在为位于不稳定的网络环境中的低算能、低带宽的边缘物联网设备提供可靠的网络服务
    MQTT协议针对低带宽、低计算能力的网络设备做了特殊的优化，使得其能适应物联网数据传输场景

OPC协议
    OPC是基于Windows COM/DCOM的工业通信协议，用于实现不同设备与软件间的数据交换。
    OPC UA是OPC的升级版，它独立于平台，内置安全机制，并支持复杂信息建模，实现了从底层设备到云端的安全、跨平台数据集成。

传统云计算模型引入边缘计算的优势
    数据通信方面
        很多计算在边缘数据中心或边缘设备本身进行处理，数据无需传输回中央服务器，可极大减少网络负载
    数据安全方面
        边缘计算将在不同的数据中心和设备之间分配数据处理工作，黑客无法通过攻击一台设备来影响整个网络
    系统性能方面
        由于很多功能直接由边缘设备完成而不需依赖于中央服务器，因此系统性能更高

UML的组成要素
    基本构造块（事物、关系）
    图（支配基本构造块如何放置在一起的规则）
    运用于整个语言的公用机制

UML中的事物
    结构事物
        静态部分，描述概念或物理元素
        包括类、接口、协作、用例、主动类、构件、制品和节点
    行为事物
        动态部分，描述跨越时间和空间的行为
        包括交互、状态机和活动
    分组事物
        组织部分
        包（Package）
    注释事物
        解释部分，用来描述、说明和标注模型的任何元素

UML中的关系
    依赖 可能有方向的虚线
        其中一个事物（独立事物）发生变化会影响另一个事物（依赖事物）的语义
    关联
        描述了一组链，链是对象之间的连接。聚集是一种特殊的关联
    泛化 带有空心箭头的实线，指向父元素
        特殊/一般关系
    实现 带有空心箭头的虚线
        两种情况下会使用实现关系
            在接口和实现它们的类或构件之间
            在用例和实现它们的协作之间

UML对象之间的消息类型
    简单消息
    返回消息
    同步消息
    异步消息
    参与者创建消息
    参与者销毁消息
    无触发对象和无接收对象的消息

UML的各种图
    顶点（代表事物）和弧（代表关系）的连通图
    顺序图 用于描述对象之间动态的交互关系，并强调消息的时间次序
    类图 用于描述系统的静态结构 类与类之间的关系：依赖、关联、聚合、组合、继承、实现
    构件图 用于描述各种软件构件之间的依赖关系、显示代码的静态结构
    用例图 用于从用户角度描述系统功能 用例与用例之间的关系：扩展、包含、泛化
    通信图 用于显示组件及其消息交互关系，不强调交互的时间次序
    活动图 用于表示系统行为或业务流程
    协作图 强调接受和发送消息的对象的组织结构及通信方式

UML顺序图中消息的类型
    同步消息
    异步消息
    返回消息
    自关联消息

UML时序图的三种消息类型
    同步消息 发送者把消息传递给接收者，然后停止活动，等待消息的接收者放弃或者返回
    异步消息 消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接收者返回消息或控制，异步消息的接收者和发送者是并发工作的
    返回消息 返回消息表示从过程调用返回

UML顺序图中常见的元素
    对象 系统中具有特定职责和行为的实体
    生命线 表示对象在交互过程中存在的时间线
    激活/控制焦点 表示对象正在执行某个动作或处于活动状态的时间段
    消息 对象之间传递的信息，用于触发接收对象的动作或状态变化
    交互片段 用于表示顺序图中的一组特殊交互，如循环、条件分支等

UML时序图和协作图的选取原则
    时序图
        1、强调时间顺序，适用于展示对象之间消息传递的时间顺序和动态行为，描述系统中的事件发生顺序
        2、展示交互的时间线，清晰展示用例或场景中各对象在不同时间点的状态变化，帮助理解系统的时间维度行为
        3、描述复杂的交互场景，适用于多个对象和复杂交互的场景，通过时间线展示消息传递的先后顺序，使复杂交互过程易于理解
    协作图
        1、强调对象间的关系，展示对象之间的链接和关系结构，适用于静态连接和通信路径的展示
        2、展示对象的结构关系，描述对象如何协作完成任务，强调对象之间的静态结构和协作方式
        3、突出对象间的通信，适用于展示对象间的通信和交互，而不是时间顺序，清晰展示对象之间的消息传递和关联关系

微服务的概念、优势与挑战
    微服务是一种架构风格，它将单体应用划分成一组小的服务，服务之间相互协作，实现业务功能的每个服务运行在独立的进程中，服务间采用轻量级的通信机制协作（通常是HTTP/JSON），
    每个服务围绕业务能力进行构建，并且能够通过自动化机制独立地部署。
    优势：
        1、通过把大的单体式应用分解为多个服务，解决了复杂性问题，同时保持了总体功能不变，但整体并发性能得到极大提升
        2、让每个服务能够独立开发，开发者能够自由选择可行的技术，提供API服务
        3、微服务架构模式是每个微服务独立部署，开发者不再需要协调其他服务的部署对本服务的影响，从而可以加快部署速度
        4、微服务使得每个服务独立扩展，从而可以根据每个服务的规模来部署满足需求的规模，甚至可以使用更适合于服务资源需求的硬件
    挑战：
        1、并非所有系统都能转成微服务
        2、系统由众多微服务搭建，部署较单体架构更加复杂，每个微服务需要单独部署从而增加部署的复杂度
        3、由于微服务注重独立性，互相通信时只能通过标准接口，可能产生性能问题或调用出错
        4、作为分布式部署的微服务，在保持数据一致性方面比传统架构更加困难

微服务架相较于传统单体架构的优势
    高可伸缩性 微服务架构允许独立地伸缩各个服务，根据业务需求灵活调整资源，而不需要对整个应用进行调整
    技术栈灵活性 每个微服务可以使用最适合其需求的技术栈进行开发，无需受限于整个应用的技术选择
    快速迭代和部署 由于服务之间的解耦，团队可以并行开发、测试和部署不同的服务，从而加快产品迭代速度
    故障隔离 单个服务的故障不会影响到整个系统，提高了系统的稳定性和可靠性
    更好的团队协作 微服务架构促进了小型、自治的团队形成，每个团队可以专注于自己的服务，提高了开发效率和代码质量

微服务之间确保数据一致性和服务的高可用
    分布式事务 使用两阶段提交（2PC）、三阶段提交（3PC）或基于SAGA模式等分布式事务解决方案，确保跨多个服务的数据一致性。然而，分布式事务可能会引入额外的复杂性和性能开销，需谨慎使用
    最终一致性 在不需要强一致性的场景下，可以采用最终一致性模型。通过事件驱动架构（EDA）或消息队列等方式，异步更新数据，并在一段时间后达到一致状态。可提高系统的可用性和性能
    服务熔断与降级 为了防止某个服务的故障影响到整个系统，可以实施服务熔断机制。当服务调用失败率达到一定阈值时，自动熔断该服务，防止进一步的失败扩散。同时，可以实施服务降级策略，
        在资源不足或系统负载过高时，提供简化的服务响应
    服务注册与发现 使用服务注册中心（如Eureka、Consul等）来管理服务的注册和发现。服务实例在启动时向注册中心注册自己，并在关闭时注销。其他服务通过注册中心来发现需要调用的服务实例，
        从而实现服务的动态发现和负载均衡
    数据复制与缓存 通过数据复制和缓存技术，提高数据的可用性和访问速度。例如，可以使用数据库的主从复制来确保数据的高可用性，并使用缓存（如Redis、Memcached等）来减少数据库的访问压力和
        提高数据访问速度
    API网关 在微服务架构中，API网关作为所有客户端请求的入口点，负责路由、过滤、认证、限流等职责。通过API网关，可以集中管理跨服务的通信和数据共享，提高系统的安全性和可维护性

RESTful和gRPC的区别
    RESTful API
        基于HTTP协议，使用JSON或XML等格式进行数据传输，具有良好的跨平台性和易用性。
        支持丰富的HTTP方法（如GET、POST、PUT、DELETE等），便于实现资源的CRUD操作
        对于电商平台而言，RESTful API因其简单性和广泛的支持度，是一个很好的选择。
        允许前端、移动应用和其他服务通过统一的接口与后端服务进行交互
    gRPC
        由Google开发，基于HTTP/2协议，支持多种语言，并使用Protocol Buffers作为接口定义语言
        gRPC在性能上略优于RESTful，特别是在需要低延时和高吞吐量的场景下
        但不如RESTful那样易于学习和使用，且对客户端的支持不如RESTful API广泛

系统可靠性
    软件产品在规定的条件下和规定的时间区间完成规定功能的能力
    在应用和系统发生错误时，在意外或错误使用的情况下维持软件系统的功能特性的基本能力

    提高系统可靠性的技术
        冗余机制
        集成监控控件
        异常处理

