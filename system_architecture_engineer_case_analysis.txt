管道-过滤器架构风格与仓库架构风格对比
    管道-过滤器架构
        数据处理方式 数据驱动机制，处理流程事先确定，交互性差
        系统可扩展性 容易添加新的过滤器，可扩展性好
        处理性能 涉及数据格式转换，有损性能；但支持过滤器并发调用，有利于性能提高
    仓库架构风格
        数据处理方式 数据统一保存在中央数据仓库，数据处理流程相对独立，支持交互式处理
        系统可扩展性 数据与处理解耦合，可动态添加和删除处理组件
        处理性能 不支持并行，有损性能；容错性和健壮性好

解释器风格、管道-过滤器风格和隐式调用风格对比
    管道-过滤器风格
        具有高内聚、低耦合、支持软件重用、扩展性好、支持并发等优点
        有编写复杂、不适合处理交互应用等缺点
    隐式调用风格
        隐式调用基于事件触发的思想，具备支持软件重用、改进系统方便等优点
        有构件放弃了对系统计算的控制、事件传递中的数据交换存在问题、语义依赖于被触发事件的上下文约束等缺点
    解释器风格
        核心是“解释”，一个规则可解释为A，另一个可解释为B，针对不同的语法规则，只需对解释器进行扩展即可，因此可应对语法规则的不断改变及扩展
        如果语法规则数量太多，会增加系统复杂性，性能下降

数据库设计的6个阶段
    用户需求分析 功能、性能、限制
        对数据库应用系统所要涉及的内容（数据）和功能（行为）的整理和描述
        综合各个用户的应用需求，对现实世界要处理的对象（组织、部门和企业等）进行详细调查，在了解现行系统的概况，确定新系统功能的过程中，收集支持系统目标的基础数据和处理方法
    概念结构设计 形成独立于计算机系统的企业信息模型；描述概念模型的理想工具：E-R图
        选择局部应用
        逐一设计分E-R图
        E-R图合并
    逻辑结构设计 将抽象的概念模型转化为与选用的DBMS产品所支持的数据模型相符合的逻辑模型，它是物理结构设计的基础。包括模式初始设计、子模式设计、应用程序设计、模式评价以及模式求精
        E-R图转化为关系模式
        关系模式规范化
        确定完整性约束
        确定用户视图 数据安全性、独立性
        反规范化 冗余列、派生列、表重组和表分割
            冗余列
                在多个表中增加相同的常用列，可用来在查询时避免连接操作
            派生列
                把可通过表中其他数据计算生成的列作为固定的列插入到表中，可在查询时减少计算量
            表重组
                如果许多用户需要查看两个表连接出来的结果数据，则把这两个表重新组成一个表来减少连接从而提高性能
            表分割
                水平分割把表按记录进行分割，把数据放到多个独立的表中，主要用于表数据规模很大、表中数据相对独立或数据需要存放到多个介质上时使用
                垂直分割对表按列进行分割，通常将主键与部分列放到一个表中，主键与其他列放到另一个表中，在查询时较少I/O次数
            带来数据不一致性，可采用应用程序同步、批量处理同步和触发器同步方法解决
                应用程序同步
                    在同一事务中对所有涉及的表进行增删改操作，同一逻辑必须在所有的应用中使用和维护，缺点是容易遗漏，特别是需求变化时，不易于维护
                批量处理同步
                    通过定期运行批处理作业或存储过程对数据库进行修改，适用于对实时性要求不高的情况
                触发器同步
                    对数据的任何修改立即触发对数据库某些列的相应修改，实时性好，也易于维护
    物理结构设计 逻辑模型的具体实现方案
        确定数据分布
            数据是集中管理还是分布式管理，如何分布
        确定数据的存储结构
            物理结构、索引
        确定数据的访问方式
            存储记录结构设计 常用数据分布在不同的磁盘组上
            存储记录布局 聚簇功能
            存取方法的设计 建立索引
    数据库实施阶段 建立数据库，编制和调试应用程序，组织数据入库，试运行
    数据库运行和维护阶段 投入使用，不断评价、调整与修改

NoSQL体系框架
    由下至上
        数据持久层
            数据存储形式 基于内存、硬盘、内存和硬盘接口、订制可插拔
        数据分布层
            数据分布
                CAP支持，可用于水平扩展
                多数据中心支持，可以保证在横跨多数据中心时也能够平稳运行
                动态部署支持，可以再运行着的集群中动态地添加和删除节点
        数据逻辑模型层
        接口层
        
对现实事物抽象认识的3中方法
    分类 对现实世界的事物，按照其具有的共同特征和行为，定义一种类型
    聚集 定义某一类型的属性
    概括 由一种已知类型定义新的类型。通常，将已知类型称为超类，新定义的类型称为子类。子类是超类的一个子集。例如研究生是学生的一个子集

Redis数据类型
    string 二进制安全的字符串，可以包含任何数据（图片或序列化对象）
    list 按添加顺序保持顺序的字符串列表
    set 无序的字符串集合
    sorted set 已排序的字符串集合
    ZSet 有序集合，每个元素有一个分数
    hash key-value对的一种集合，更节省空间，描述用户信息较为方便
    bitmap 更细化的一种操作，以bit为单位
    hyperloglog 基于概率的数据结构
    geo 存储地理位置信息
    stream 流，相当于消息队列的topic

Redis持久化
    RDB（Redis Data Base）持久化方式
    AOF（Append Only File）持久化方式
        磁盘更新频率 RDB更新频率比AOF低
        数据安全 AOF可以保证数据不丢失，比RDB安全
        数据一致性 RDB间隔一段时间存储，可能发生数据丢失和不一致；AOF通过append模式写文件，即使服务器宕机，也可通过redis-check-aof工具解决数据一致性问题
        重启性能 RDB比AOF更高
        数据文件大小 RDB更小

Redis内存淘汰机制
    volatile-lru 针对设置了过期时间的key，使用lru（Least Recently Used，最近很少使用）算法进行淘汰
    allkeys-lru 针对所有key使用lru算法进行淘汰
    volatile-lfu 针对设置了过期时间的key，使用lfu（Least Frequently Used，最近很少使用）算法进行淘汰
    allkeys-lfu 针对所有key使用lfu算法进行淘汰
    volatile-random 针对设置了过期时间的key，随机淘汰
    allkeys-random 对所有key，随机淘汰
    volatile-ttl 针对设置了过期时间的key，越早过期的越早被淘汰
    noeviction 不淘汰任何数据，内存超过限制时写入报错

Redis和MySQL数据实时同步方案
    引用MySQL的事务，事务有一致性保证，事务提交成功后再更新缓存
    在缓存中引用访问控制位，数据库数据变化后，同步变更对应的访问控制位，然后从缓存查询时，首先检查访问控制位，有变化就从数据库查，无变化直接从缓存返回数据
    通过数据库中间件产品保证缓存和数据库数据的实时同步

TCP和UDP协议对比
    TCP在IP协议提供的不可靠数据服务的基础上，采用了重发技术，为应用程序提供了一个可靠的、面向连接的、全双工的数据传输服务
        一般用于传输数据量比较少，且对可靠性要求高的场景
    UDP是一种不可靠的、无连接的协议，可以保证应用程序进程间的通信
        与TCP相比，UDP是一种无连接的协议，错误检测功能较弱
